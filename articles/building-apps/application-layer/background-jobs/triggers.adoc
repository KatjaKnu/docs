---
title: Triggering Jobs
description: How to trigger backgorund jobs
order: 20
---

= Triggering Jobs

A trigger is an object that starts a job. It decides which thread the job should execute in, executes it, and handles any errors that occurred.

Business applications have many different triggers. You may want to trigger some jobs on application startup. Other jobs may run once a week, every day at midnight, or every five minutes. Some jobs may run in response to application events, and other in response to user input. You might even have some jobs that can be triggered through a REST API, or through Java Management Extensions (JMX).

As was mentioned earlier, the same job can have more than one trigger.

// === Startup Jobs

== Scheduled Jobs

For scheduled jobs, you should create a _scheduler_ that uses Spring's scheduling mechanism to trigger the job. 

Spring uses a separate thread pool for scheduled tasks. You should not use this thread pool to execute the jobs. Instead, your schedulers should hand over the jobs to the `TaskExecutor`. 

Before you can create a scheduler, you have to enable scheduling and asynchronous execution. To do this, add the `@EnableAsync` and the `@EnableScheduling` annotations to your main application class:

[source,java]
----
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableAsync
@EnableScheduling
public class Application implements AppShellConfigurator {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
----

Since the scheduler is not intended to be called by any other objects, you should make it package private.

A declarative scheduler looks like this:

[source,java]
----
@Component
class MyBackgroundJobScheduler {

    private static final Logger log = LoggerFactory.getLogger(MyBackgroundJobScheduler.class);
    private final MyBackgroundJob job;

    MyBackgroundJobScheduler(MyBackgroundJob job) {
        this.job = job;
    }

    @Scheduled(fixedRate = 5, timeUnit = TimeUnit.MINUTES) // <1>
    @Async // <2>
    public void performBackgroundJob() {
        try {
            job.performBackgroundJob(); // <3>
        } catch (Exception ex) {
            log.error("Error performing background job", ex); // <4>
        }
    }
}
----
<1> The job is executed every 5 minutes.
<2> The job is executed by the `TaskExecutor`, not by the scheduling thread pool.
<3> The scheduler object delegates to the job object.
<4> Log any errors, or handle them in some other way.

If you prefer a more explicit, programmatic approach, you could do the following:

[source,java]
----
@Component
class MyBackgroundJobScheduler {

    private static final Logger log = LoggerFactory.getLogger(MyBackgroundJobScheduler.class);
    private final MyBackgroundJob job;
    private final TaskExecutor taskExecutor;
    private final TaskScheduler taskScheduler;
    
    MyBackgroundJobScheduler(MyBackgroundJob job, 
            TaskExecutor taskExecutor, 
            TaskScheduler taskScheduler) {
        this.job = job;
        this.taskExecutor = taskExecutor;
        this.taskScheduler = taskScheduler;
    }

    @EventListener
    public void onApplicationReadyEvent(ApplicationReadyEvent event) { // <1>
        taskScheduler.scheduleAtFixedRate(
            () -> taskExecutor.execute(this::performBackgroundJob),
            Duration.ofMinutes(5)
        );
    }

    private void performBackgroundJob() {
        try {
            job.performBackgroundJob();
        } catch (Exception ex) {
            log.error("Error performing background job", ex);
        }        
    }
}
----
<1> This event is fired once, when the application has started up and is ready to serve requests.

Programmatic schedulers are more verbose, but they are easier to debug. You should start with declarative schedulers, and switch to programmatic ones if you need more control over the scheduling, or run into problems that are difficult to debug.

See the https://docs.spring.io/spring-framework/reference/integration/scheduling.html[Spring Documentation] for more information about task scheduling.

== Event Triggered Jobs

For event triggered jobs, you should create an _event listener_ that receives events from Spring's event publisher. By default, the event publisher calls each listener in the same thread that published the event. This can be overridden, but it is easier to handle it in the listener implementation itself.

Since the listener is not intended to be called by any other objects, you should make it package private.

A listener looks like this:

[source,java]
----
@Component
class PerformBackgroundJobOnMyEventTrigger {
    private static final Logger log = LoggerFactory.getLogger(PerformBackgroundJobOnMyEventTrigger.class);
    private final MyBackgroundJob job;
    private final TaskExecutor taskExecutor;
    
    PerformBackgroundJobOnMyEventTrigger(MyBackgroundJob job, 
            TaskExecutor taskExecutor) {
        this.job = job;
        this.taskExecutor = taskExecutor;
    }

    @EventListener
    public void onMyEvent(MyEvent event) {
        taskExecutor.execute(this::performBackgroundJob);
    }

    private void performBackgroundJob() {
        try {
            job.performBackgroundJob();
        } catch (Exception ex) {
            log.error("Error performing background job", ex);
        }        
    }
}
----

== User Triggered Jobs

For user triggered jobs, an <<application-services#,application service>> acts as the trigger.

[source,java]
----
@Service
public class MyApplicationService {

    @Test
    public void startBackgroundJob() {

    }

}
----

If the job needs to interact with the user interface in some way, either while running, or after it has finished, it becomes a bit more involved. This is explained in the next section.
