---
title: UI Interaction
description: How to interact with jobs from the user interface.
order: 25
---

= UI Interaction

Some background jobs execute business processes in the background. The end user may see the result of the background job, but does not have to interact with the directly. Scheduled jobs and event triggered jobs typically fall in this category.

Then there are jobs that need to interact with the user interface. For instance, the job may want to update a progress indicator while running, and notify the user when the job has completed, or an error has occurred. Furthermore, the user may want to be able to cancel a running job before it has completed.

On this page, you'll learn different ways of doing this that work with both Flow and Hilla.

== Callbacks [badge-flow]#Flow# 

If you are using a Flow user interface, the simplest way of allowing your background jobs to interact with it is through callbacks.

You can use `Consumer`, `Runnable`, and `Supplier` as callback interfaces, depending on how you want to interact with the background job.

[cols="1,1"]
|===
|Event |Callback

|Completed without a result
|`Runnable`

|Completed with a result of type `T`
|`Consumer<T>`

|Completed with an exception
|`Consumer<Exception>`

|Reported percentage done
|`Consumer<Double>`

|Cancelled by user
|`Supplier<Boolean>`

|===

For example, a background job that returns a string or an exception could be implemented like this:

[source,java]
----
@Async
public void startBackgroundJob(Consumer<String> onComplete, 
                               Consumer<Exception> onError) {
    try {
        var result = doSomethingThatTakesALongTime();
        onComplete.accept(result);
    } catch (Exception ex) {
        onError.accept(result);
    }
}
----

If the background job is also reporting its progress, for instance as a percentage number, it could look like this:

[source,java]
----
@Async
public void startBackgroundJob(Consumer<String> onComplete, 
                               Consumer<Double> onProgress, 
                               Consumer<Exception> onError) {
    try {
        onProgress.apply(0.0);

        var step1Result = performStep1();
        onProgress.apply(0.25);

        var step2Result = performStep2(step1Result);
        onProgress.apply(0.50);

        var step3Result = performStep3(step2Result);
        onProgress.apply(0.75);

        var result = performStep4(step3Result);
        onProgress.apply(1.0);

        onComplete.accept(result);
    } catch (Exception ex) {
        onError.accept(ex);
    }
}
----

Furthermore, if the job can also be cancelled, it could look like this:

[source,java]
----
@Async
public void startBackgroundJob(Consumer<String> onComplete, 
                               Consumer<Double> onProgress, 
                               Consumer<Exception> onError,
                               Supplier<Boolean> isCancelled) {
    try {
        onProgress.apply(0.0);

        if (isCancelled.get()) {
            return;
        }
        var step1Result = performStep1();
        onProgress.apply(0.25);

        if (isCancelled.get()) {
            return;
        }
        var step2Result = performStep2(step1Result);
        onProgress.apply(0.50);

        if (isCancelled.get()) {
            return;
        }
        var step3Result = performStep3(step2Result);
        onProgress.apply(0.75);

        if (isCancelled.get()) {
            return;
        }
        var result = performStep4(step3Result);
        onProgress.apply(1.0);

        onComplete.accept(result);
    } catch (Exception ex) {
        onError.accept(ex);
    }
}
----

All the callbacks have to be thread-safe, as they are called from the background thread, but owned and created by the user interface. For more information about how to implement these callbacks, see the <<{articles}/building-apps/presentation-layer/server-push/callbacks#,Server Push - Callbacks>> documentation page.

=== Improving Cancel API

If you want to make the cancelling API nicer, you can replace the callback with a handle. First, create a handle interface that the user interface can use to cancel the job:

[source,java]
----
@FunctionalInterface
public interface CancellableJob {
    void cancel();
}
----

Next, implement the service method like this:

[source,java]
----
public CancellableJob startBackgroundJob(Consumer<String> onComplete, 
                                         Consumer<Double> onProgress
                                         Consumer<Exception> onError) {
    var cancelled = new AtomicBoolean(false);
    taskExecutor.execute(() -> {
        try {
            onProgress.apply(0.0);

            if (cancelled.get()) {
                return;
            }
            var step1Result = performStep1();
            onProgress.apply(0.25);

            if (cancelled.get()) {
                return;
            }
            var step2Result = performStep2(step1Result);
            onProgress.apply(0.50);

            if (cancelled.get()) {
                return;
            }
            var step3Result = performStep3(step2Result);
            onProgress.apply(0.75);

            if (cancelled.get()) {
                return;
            }
            var result = performStep4(step3Result);
            onProgress.apply(1.0);

            onComplete.accept(result);
        } catch (Exception ex) {
            onError.accept(result);
        }
    });
    return () -> cancelled.set(true);
}
----

The user interface would have to store the handle while the job is running, and call the `cancel()` method to cancel it. Note, that you cannot use the `@Async` annotation in this case. This is because `@Async` methods can only return `void` or future-like types. In this case, you want to return neither.

The handle itself is thread safe because you are using an `AtomicBoolean`. You do not need to take any special precautions to call it from the user interface.

== CompletableFuture [badge-flow]#Flow#

If you are using a Flow user interface, you can use a standard Java `CompletableFuture` to report results and errors to the user interface. You can also use it to cancel the job from the user interface. For reporting progress, however, you still need to use a callback.

The advantage of working with `CompletableFuture` is that Spring has built-in support for them when using the `@Async` annotation. For example, a background job that completes with either a string or an exception could be implemented like this:

[source,java]
----
@Async
public CompletableFuture<String> startBackgroundJob() {
    return CompletableFuture.completedFuture(doSomethingThatTakesALongTime());
}
----

If the `doSomethingThatTakesALongTime()` method throws an exception, Spring automatically returns a `CompletableFuture` with the exception in question.

To update the user interface, you have to add special completion stages that execute after the `CompletableFuture` completes. For more information about how to add these, see the <<{articles}/building-apps/presentation-layer/server-push/futures#,Server Push - Futures>> documentation page.

=== Cancelling

You can cancel a Java `Future` by calling its `cancel()` method. The method has a `boolean` parameter that indicates whether the thread should be interrupted or not. However, `CompletableFuture`, which implements `Future`, does not use this parameter. It therefore does not make any difference whether you pass in `true` or `false`.

When you cancel a `CompletableFuture`, it completes with a `CompletionException` caused by a `CancellationException`. However, the job continues to silently run in the background until it has finished. If you want to notify the job itself that it has been cancelled, and should stop running at the next suitable moment, you have to make some changes.

`CompletableFuture` has an `isCancelled()` method that you can use to query whether the job has been cancelled or not. However, do to this, you cannot use the `@Async` annotation anymore. Instead, you have to manually execute the job using the `TaskExecutor`, and manage the state of the returned `CompletableFuture`. The principle is the same as when you are using callbacks or handles.

The earlier example would look like this when implemented using a `CompletableFuture`:

[source,java]
----
public CompletableFuture<String> startBackgroundJob() {
    var future = new CompletableFuture<String>();
    taskExecutor.execute(() -> {
        try {
            var step1Result = performStep1();

            if (future.isCancelled()) {
                return;
            }
            var step2Result = performStep2(step1Result);

            if (future.isCancelled()) {
                return;
            }
            var step3Result = performStep3(step2Result);

            if (future.isCancelled()) {
                return;
            }
            var result = performStep4(step3Result);
            future.complete(result);
        } catch (Exception ex) {
            future.completeExceptionally(ex);
        }
    });
    return future;
}
----

You do not need to do anything with the `future` after it has been cancelled, as it has already been completed. Returning is enough.

== Flux and Mono

If you are using Flow or Hilla to build your user interface, you can use `Flux` or `Mono` from https://projectreactor.io/[Reactor] to allow your background jobs to interact with them. Reactor has an extensive API, which means you can do a lot of things with it. This also means that it has a steeper learning curve than using callbacks or `CompletableFuture`. If you are new to reactive programming, you should read Reactor's https://projectreactor.io/docs/core/release/reference/#intro-reactive[Introduction to Reactive Programming] before continuing.

When you are using Reactor, you cannot use the `@Async` annotation. Instead, you have to manually instruct your `Mono` or `Flux` to execute using the Spring `TaskExecutor`. Otherwise, your job executes in the thread that subscribes to the `Mono` or `Flux`.

For example, a background job that returns a string or an exception could be implemented like this:

[source,java]
----
public Mono<String> startBackgroundJob() {
    return Mono.fromSupplier(this::doSomethingThatTakesALongTime)
               .subscribeOn(Schedulers.fromExecutor(taskExecutor));
}
----

If the `doSomethingThatTakesALongTime()` method throws an exception, the `Mono` terminates with an error.

To update the user interface, you have to subscribe to the `Mono` or `Flux`. For more information about how to do this, see the <<{articles}/building-apps/presentation-layer/server-push/reactive#,Server Push - Reactive Streams>> documentation page.

[IMPORTANT]
Hilla only supports `Flux`, so if your job is returning a `Mono`, you have to convert it to a `Flux` inside your `@BrowserCallable` endpoint. You can do this by calling the `Mono.flux()` method.

=== Reporting Progress

If your background job only needs to report its progress without actually returning a result, you can return a `Flux<Double>`. Your job should then emit progress updates, and complete the stream when done. However, you often also want to return a result. Since Hilla only supports returning a single `Flux`, you have to use the same stream for emitting both progress updates and the end result. The code may be a bit messy, but it works.

You first need to create a data type that can contain both progress updates and the result. For a job that returns a string, it could look like this:

[source,java]
----
import com.vaadin.hilla.Nullable;

public record BackgroundJobOutput(
        @Nullable Double progressUpdate, 
        @Nullable String result
) {
    public static BackgroundJobOutput progressUpdate(double progressUpdate) {
        return new BackgroundJobOutput(progressUpdate, null);
    }

    public static BackgroundJobOutput finished(String result) {
        return new BackgroundJobOutput(null, result);
    }
}
----

The two factory methods `progressUpdate()` and `finished()` make the code look better when it is time to create instances of `BackgroundJobOutput`.

[NOTE]
If you have worked with sealed classes, you may be tempted to create a sealed interface called `BackgroundJobOutput`, and then create two records that implement that interface: one for progress updates, and another for the result. However, Hilla does not support this at the moment.

Next, you have to implement the background job like this:

[source,java]
----
private String doSomethingThatTakesALongTime(Consumer<Double> onProgress) {
    ...
}

public Flux<BackgroundJobOutput> startBackgroundJob() {
    Sinks.Many<Double> progressUpdates = Sinks // <1>
        .many()
        .unicast() 
        .onBackpressureError(); 

    var result = Mono // <2>
        .fromSupplier(() -> doSomethingThatTakesALongTime(
            progressUpdates::tryEmitNext
        ))
        .subscribeOn(Schedulers.fromExecutor(taskExecutor));

    return Flux.merge( // <3>
        progress.asFlux().map(BackgroundJobOutput::progressUpdate),
        result.map(BackgroundJobOutput::finished)
    );
}
----
<1> Create a sink that you can emit progress updates to.
<2> Create a `Mono` that emits the result of the background job.
<3> Map both streams to `BackgroundJobOutput` and merge them.

When your user interface subscribes to this `Flux`, it needs to check the state of the returned `BackgroundJobOutput` objects. If `progressUpdate` contains a value, it should update the progress indicator. If `result` contains a value, the operation is finished.

=== Cancelling

You can cancel a subscription to a `Flux` or `Mono` at any time. However, as with `CompletableFuture`, cancelling the subscription does not stop the background job itself. To fix this, you need to tell the background job when it has been cancelled, so that it can stop itself. Continuing on the earlier example, adding support for cancelling could look like this:

[source,java]
----
private String doSomethingThatTakesALongTime(
    Consumer<Double> onProgress, 
    Supplier<Boolean> isCancelled) {
    ...
}

public Flux<BackgroundJobOutput> startBackgroundJob() {
    var cancelled = new AtomicBoolean(false);
    Sinks.Many<Double> progressUpdates = Sinks
        .many()
        .unicast() 
        .onBackpressureError(); 

    var result = Mono
        .fromSupplier(() -> doSomethingThatTakesALongTime(
            progressUpdates::tryEmitNext, cancelled::get
        ))
        .doOnCancel(() -> cancelled.set(true))
        .subscribeOn(Schedulers.fromExecutor(taskExecutor));

    return Flux.merge(
        progress.asFlux().map(BackgroundJobOutput::progressUpdate),
        result.map(BackgroundJobOutput::finished)
    );
}
----

If the user interface cancels the subscription, the `cancelled` flag becomes `true`, and the job stops executing at its next iteration.
