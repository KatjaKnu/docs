---
title: Futures
description: How to use server push with `CompletableFuture`.
order: 30
section-nav: badge-flow
---

= Futures [badge-flow]#Flow#

If you are building the user interface with Flow, a background thread can use the standard Java `CompletableFuture` to inform the user interface of results and errors. This is a good approach if you are already used to working with `CompletableFuture`.

For example, a background job that returns a string or an exception could be implemented like this:

[source,java]
----
@Async
public CompletableFuture<String> startBackgroundJob() {
    return CompletableFuture.completedFuture(doSomethingThatTakesALongTime());
}
----

If `doSomethingThatTakesALongTime()` throws an exception, Spring automatically returns a `CompletableFuture` that is completed with the exception.

If you also need to report progress, you can combine this approach with <<callbacks#,a callback>>.

// This text assumes the logic behind `UI.access()` and `UI.accessLater()` has been explained earlier, including how to get the `UI` instance itself.

In fact, you are using callbacks in this approach as well, but instead of calling them directly from your background thread, you are registering them with `CompletableFuture`. However, the principle is the same: create private methods that can be passed as `Consumers` to `UI.accessLater()`. For example, a method for handling successful completion could look like this:

[source,java]
----
private void onJobCompleted(String result) {
    Notification.show("Job completed: " + result);
}
----

Likewise, a method for handling errors could look like this:

[source,java]
----
private void onJobFailed(Throwable error) {
    Notification.show("Job failed: " + error.getMessage());
}
----

Note, that the error handler must accept a `Throwable` and not an `Exception` when you are working with `CompletableFuture`.

== Successful Completion

If a `CompletableFuture` completes successfully, you can instruct it to perform a specific operation by calling the `thenAccept()` method on it. This method takes a `Consumer` object as its input. When the `CompletableFuture` completes, it calls this object with the result.

You use it to update your user interface like this:

[source,java]
----
private void startJob() {
    var ui = UI.getCurrent();
    service.startBackgroundJob().thenAccept(ui.accessLater(this::onJobCompleted, null));
}
----

However, this version does not yet handle any exceptions.

== Exceptional Completion

If a `CompletableFuture` is completed with an exception, you can instruct it to perform a specific operation by calling the `exceptionally()` method on it. However, this method works in a different way than `thenAccept()`. It takes a `Function` instead of a `Consumer` object as input. The exception is passed to the function as input. The function output is used as the result of the `CompletableFuture` that is returned by `exceptionally()`.

Flow has no version of `UI.accessLater()` that works with `Function`. However, since you are not interested in returning a result, you can create a helper function that adapts a `Consumer` to a `Function`, like this:

[source,java]
----
public static <T> Function<T, Void> consumerToFunction(Consumer<T> consumer) {
    return input -> {
        consumer.accept(input);
        return null;
    };
}
----

With this helper function in place, the code for starting the job with error handling now becomes:

[source,java]
----
private void startJob() {
    var ui = UI.getCurrent();
    service.startBackgroundJob()
        .thenAccept(ui.accessLater(this::onJobCompleted, null))
        .exceptionally(consumerToFunction(ui.accessLater(this::onJobFailed, null)))
}
----

You would then call the `startJob()` method when a user clicks a button, for instance. If the UI has already been detached when the background thread completes, you do not have to do anything. Because of this, no detach handler is passed to `ui.accessLater()`.